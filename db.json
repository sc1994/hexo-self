{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/miho/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/miho/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/miho/source/images/alipay.png","path":"images/alipay.png","modified":0,"renderable":1},{"_id":"themes/miho/source/images/alipay_code.jpg","path":"images/alipay_code.jpg","modified":0,"renderable":1},{"_id":"themes/miho/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/miho/source/images/scrollbar_arrow.png","path":"images/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/miho/source/images/wechat.png","path":"images/wechat.png","modified":0,"renderable":1},{"_id":"themes/miho/source/images/wechat_code.jpg","path":"images/wechat_code.jpg","modified":0,"renderable":1},{"_id":"themes/miho/source/js/animate.js","path":"js/animate.js","modified":0,"renderable":1},{"_id":"themes/miho/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/miho/source/js/particles.js","path":"js/particles.js","modified":0,"renderable":1},{"_id":"themes/miho/source/js/pace.min.js","path":"js/pace.min.js","modified":0,"renderable":1},{"_id":"themes/miho/source/js/pop-img.js","path":"js/pop-img.js","modified":0,"renderable":1},{"_id":"themes/miho/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/miho/source/images/banner.jpg","path":"images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/miho/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/miho/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/miho/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/miho/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/miho/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/miho/.gitignore","hash":"854da42f35444ed19a8164cb7c213f66ae0e178c","modified":1535432555275},{"_id":"themes/miho/_config.yml","hash":"4576c4c71ece1ab4ca25d5528e5a65c32a660ddf","modified":1535432555276},{"_id":"themes/miho/README.md","hash":"f16f228b9e13e6dab38d1569d7e99669d640faf2","modified":1535432555275},{"_id":"source/_posts/hello-world.md","hash":"029f91fccbe8f87c0f3ea10c4042300d2fa7edc0","modified":1535432472044},{"_id":"themes/miho/.git/config","hash":"a73999bb55731d92112cd256bab9349d1d325b83","modified":1535432555264},{"_id":"themes/miho/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1535432555258},{"_id":"themes/miho/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1535432551615},{"_id":"themes/miho/.git/index","hash":"e3a5d0205cc839baad5cb47a172916050b18dfbb","modified":1535432555322},{"_id":"themes/miho/.git/packed-refs","hash":"6ca5d24e3cd328345b7ecb376bcf28f745204b4d","modified":1535432555250},{"_id":"themes/miho/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1535432555295},{"_id":"themes/miho/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1535432555296},{"_id":"themes/miho/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1535432555296},{"_id":"themes/miho/layout/layout.ejs","hash":"8ddf881c939ba91919abc3077e0ea53418e00a6a","modified":1535432555296},{"_id":"themes/miho/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1535432555297},{"_id":"themes/miho/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1535432555297},{"_id":"themes/miho/source/favicon.ico","hash":"35e86b04bcdeeec0cabdee2e968db69aa8202788","modified":1535432555312},{"_id":"themes/miho/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1535432555297},{"_id":"themes/miho/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1535432555278},{"_id":"themes/miho/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1535432555278},{"_id":"themes/miho/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1535432555278},{"_id":"themes/miho/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1535432555279},{"_id":"themes/miho/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1535432555279},{"_id":"themes/miho/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1535432555280},{"_id":"themes/miho/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1535432555279},{"_id":"themes/miho/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1535432551618},{"_id":"themes/miho/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1535432551617},{"_id":"themes/miho/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1535432551618},{"_id":"themes/miho/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1535432551619},{"_id":"themes/miho/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1535432551620},{"_id":"themes/miho/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1535432551621},{"_id":"themes/miho/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1535432551621},{"_id":"themes/miho/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1535432551623},{"_id":"themes/miho/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1535432551625},{"_id":"themes/miho/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1535432551622},{"_id":"themes/miho/.git/logs/HEAD","hash":"0cdba19acd8d1e1590ad867e4aa0ae25d52b09b3","modified":1535432555261},{"_id":"themes/miho/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1535432551623},{"_id":"themes/miho/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1535432551624},{"_id":"themes/miho/_source/about/index.md","hash":"e23142c5eea57af6304413b2cf69d85826afbc72","modified":1535432555277},{"_id":"themes/miho/_source/blog/installation-configuration.md","hash":"b31df05ea1544a1e99e50693ef4b60b850f3bae2","modified":1535432555277},{"_id":"themes/miho/layout/_partial/after-footer.ejs","hash":"b8e3f77bea8cb0464dbd0fa3e664f96ecafd647b","modified":1535432555281},{"_id":"themes/miho/layout/_partial/archive-post.ejs","hash":"38bb2d96e64aad408ce5245cac8a43bc83995839","modified":1535432555281},{"_id":"themes/miho/layout/_partial/archive.ejs","hash":"2deeffb3851eee9594088a9e20325fb041e3006c","modified":1535432555282},{"_id":"themes/miho/layout/_partial/article.ejs","hash":"c904d9cb2cab7fddc0e038ebfb18ac42679e56e8","modified":1535432555282},{"_id":"themes/miho/layout/_partial/footer.ejs","hash":"2961c3ef06906cd18bcb1e5d3581475e83ed8670","modified":1535432555282},{"_id":"themes/miho/layout/_partial/head.ejs","hash":"412b063af00401aa2647e5ec9c30c3a961db144b","modified":1535432555283},{"_id":"themes/miho/layout/_partial/header.ejs","hash":"9f03288d4a29e9a4fd7400540e7ff9c1dcbbb22e","modified":1535432555283},{"_id":"themes/miho/layout/_partial/mobile-nav.ejs","hash":"97d02977ed2fa70dde4b25deb87d1b12e5e58301","modified":1535432555284},{"_id":"themes/miho/layout/_widget/archive.ejs","hash":"0fe1e52c291c9499bd05b966e0b9aac5be351c58","modified":1535432555294},{"_id":"themes/miho/layout/_partial/sidebar.ejs","hash":"e321e88ea82474f51ea031846b8e42c216f0a0b4","modified":1535432555293},{"_id":"themes/miho/layout/_widget/category.ejs","hash":"866790acc13fed44b7ef74c3e19c300a3d6180d8","modified":1535432555294},{"_id":"themes/miho/layout/_widget/tag.ejs","hash":"6017c54a8c3c8ff8db491cfbea3100c139da75d6","modified":1535432555295},{"_id":"themes/miho/layout/_partial/search.ejs","hash":"b7e2df6a7ca6c6d2d26039cb10c1e92480000e7f","modified":1535432555293},{"_id":"themes/miho/layout/_widget/recent_posts.ejs","hash":"16800f85ffb036d2644a26e02facd61acb3706e9","modified":1535432555295},{"_id":"themes/miho/layout/_widget/tagcloud.ejs","hash":"7259c179aa0c41c02e467ad892292e90430aaabc","modified":1535432555295},{"_id":"themes/miho/source/css/_extend.styl","hash":"7506d6eca9c34029817b90ebcbfe0398cf49a0d8","modified":1535432555298},{"_id":"themes/miho/source/css/_variables.styl","hash":"00f67e78896e78ce9e498beaf485c4091e60f777","modified":1535432555306},{"_id":"themes/miho/source/css/style.styl","hash":"2b4e7bf607e7d3429d77014c46acdb15aa3309ad","modified":1535432555312},{"_id":"themes/miho/source/images/alipay.png","hash":"b3f9db844b1e522fc55125302f2979f50a6d0529","modified":1535432555313},{"_id":"themes/miho/source/images/alipay_code.jpg","hash":"3b328818714af7fbf7b20748d783c861d876fd5b","modified":1535432555314},{"_id":"themes/miho/source/images/logo.png","hash":"f1d5d676b78b087ba2a1f177f7ca949c4c8296e4","modified":1535432555317},{"_id":"themes/miho/source/images/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1535432555317},{"_id":"themes/miho/source/images/wechat.png","hash":"8de97bf5bb3f3a0845e02172f79d6bba2fb6bb3b","modified":1535432555317},{"_id":"themes/miho/source/images/wechat_code.jpg","hash":"4a5d67c6aed4a266ab0ddac7488361cfa01cf694","modified":1535432555318},{"_id":"themes/miho/source/js/animate.js","hash":"c9776b5e345e00b020261220518a472e8d61b61c","modified":1535432555319},{"_id":"themes/miho/source/js/main.js","hash":"bdd264350095f87aca9a4105c64ecf462f90ad20","modified":1535432555319},{"_id":"themes/miho/source/js/particles.js","hash":"b71ddbfc4b1775585bc0632306db4ddc9bd004d4","modified":1535432555320},{"_id":"themes/miho/source/js/pace.min.js","hash":"64759f14e0f92d62df57eb752f1745a16aba93ce","modified":1535432555320},{"_id":"themes/miho/source/js/pop-img.js","hash":"5d0ff39a25cc37276ca3a16912ee2bff1a6e4667","modified":1535432555320},{"_id":"themes/miho/source/js/search.js","hash":"638af875aabf0b8a5a318380f9220c4da682831f","modified":1535432555321},{"_id":"themes/miho/source/images/banner.jpg","hash":"e1d7853fb02b68ee6adcc2d9b3ca647bc802e9a9","modified":1535432555316},{"_id":"themes/miho/.git/objects/pack/pack-9cc60fc72be4d61d4a6868ad87b5b14281de76cc.idx","hash":"dca5ffe14b268eb614d20c907fba20ec96453b8e","modified":1535432555209},{"_id":"themes/miho/layout/_partial/post/category.ejs","hash":"16128d2422645e18d1b6882d4c4df17d895bd76e","modified":1535432555289},{"_id":"themes/miho/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1535432555290},{"_id":"themes/miho/layout/_partial/post/copyright.ejs","hash":"3aa84af1521d87025d2b6fc35845ce763791dfa6","modified":1535432555290},{"_id":"themes/miho/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1535432555290},{"_id":"themes/miho/layout/_partial/post/nav.ejs","hash":"e99ca2902c980013cd19e859afe64c7bd3cc176d","modified":1535432555291},{"_id":"themes/miho/layout/_partial/post/reward.ejs","hash":"f82c4eb8fe0439c29cef1ec33c88314257ed4528","modified":1535432555291},{"_id":"themes/miho/layout/_partial/post/share.ejs","hash":"b58e4c1f28d2430c6b992b434a6dc0cdf80f75a1","modified":1535432555292},{"_id":"themes/miho/layout/_partial/post/title.ejs","hash":"577659dc67c89ef0a45dae5d715f20f4a48f8c6a","modified":1535432555292},{"_id":"themes/miho/layout/_partial/post/tag.ejs","hash":"9ed9626100a8500ab76ef398c0efad02f0db99e3","modified":1535432555292},{"_id":"themes/miho/.git/refs/heads/master","hash":"0228ad4e8fd4d1eac83928f10f19b4fa4516e6a8","modified":1535432555260},{"_id":"themes/miho/source/css/_partial/archive.styl","hash":"b24ada27c79e6cdb4c7ef1b53bf133bd5b12da60","modified":1535432555299},{"_id":"themes/miho/source/css/_partial/article.styl","hash":"0e90c0f0d506395d1fd4e8c47b79a3a9fafacb97","modified":1535432555299},{"_id":"themes/miho/layout/_partial/post/toc.ejs","hash":"2eaf42847685517d3a80fd6263478540c8ab1e82","modified":1535432555293},{"_id":"themes/miho/source/css/_partial/comment.styl","hash":"15b4a3dec7b6d4292efd8766659a3d2d3dbe0e64","modified":1535432555300},{"_id":"themes/miho/source/css/_partial/highlight.styl","hash":"d653170143c1b1a60cf00ce064c49361de8c95ec","modified":1535432555301},{"_id":"themes/miho/source/css/_partial/header.styl","hash":"963689b617d51617cdac681a91f38f569c59e901","modified":1535432555301},{"_id":"themes/miho/source/css/_partial/mobile.styl","hash":"96e410dc5143e6d3afbcb4eae20cf9faf11b489f","modified":1535432555301},{"_id":"themes/miho/source/css/_partial/footer.styl","hash":"7bd980e4507e6a1a0b8d788a4be86fa307bd0ef9","modified":1535432555300},{"_id":"themes/miho/source/css/_partial/pace.styl","hash":"2efcfd53aff0edf29ca1ed83dc3dbe38cffb0fdd","modified":1535432555302},{"_id":"themes/miho/source/css/_partial/post.styl","hash":"d251e92518efe460c1d7d1d85fbfce63515207a3","modified":1535432555302},{"_id":"themes/miho/source/css/_partial/reward.styl","hash":"e2e240eadeeca82339fe75e84c26c9b0853c9404","modified":1535432555302},{"_id":"themes/miho/source/css/_partial/share.styl","hash":"e5ba469a164cefbf538e9e4cabeb432982924690","modified":1535432555303},{"_id":"themes/miho/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1535432555305},{"_id":"themes/miho/source/css/_partial/scroll.styl","hash":"df80c3dbfd3db3b17c297d80957c9f8feeed3180","modified":1535432555303},{"_id":"themes/miho/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1535432555306},{"_id":"themes/miho/source/css/_partial/sidebar-aside.styl","hash":"1fb15f13ba70d5b954f62920c6b63d26e2fb2985","modified":1535432555303},{"_id":"themes/miho/source/css/_partial/sidebar-bottom.styl","hash":"4132e25ba9680c4b911a01abc75f501cda3fa4f1","modified":1535432555304},{"_id":"themes/miho/source/css/_partial/sidebar.styl","hash":"895b4a6235cb8781de6b7beb40657b961ad170d8","modified":1535432555304},{"_id":"themes/miho/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1535432555308},{"_id":"themes/miho/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1535432555308},{"_id":"themes/miho/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1535432555312},{"_id":"themes/miho/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1535432555311},{"_id":"themes/miho/.git/logs/refs/heads/master","hash":"0cdba19acd8d1e1590ad867e4aa0ae25d52b09b3","modified":1535432555262},{"_id":"themes/miho/layout/_partial/plugins/analytics/baidu-analytics.ejs","hash":"e72a08ad3f7b43e7e9f09b005523cdc2f38356ac","modified":1535432555286},{"_id":"themes/miho/layout/_partial/plugins/analytics/cnzz-analytics.ejs","hash":"73d033c49c67edbcb76e1fd0d2a0c6e8da35d21f","modified":1535432555286},{"_id":"themes/miho/layout/_partial/plugins/analytics/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1535432555286},{"_id":"themes/miho/layout/_partial/plugins/comments/changyan.ejs","hash":"f63a8e1d504323414c3f57b706587484af8a4782","modified":1535432555287},{"_id":"themes/miho/layout/_partial/plugins/comments/gitment.ejs","hash":"595699e406a211bd213e32fdd04b6aa0b6c8fdb7","modified":1535432555287},{"_id":"themes/miho/layout/_partial/plugins/comments/wangyiyun.ejs","hash":"d293bd3c5888501efd1f6c96a7e10756bdfe8ccc","modified":1535432555288},{"_id":"themes/miho/layout/_partial/plugins/comments/youyan.ejs","hash":"d49afa528a4db04355ec0d1cff8fe4a0a005410f","modified":1535432555288},{"_id":"themes/miho/layout/_partial/plugins/sites/visit.ejs","hash":"bb1df834bb2f0501ce7fc1acb57e054732e6f9cb","modified":1535432555289},{"_id":"themes/miho/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1535432555257},{"_id":"themes/miho/source/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1535432555310},{"_id":"themes/miho/.git/logs/refs/remotes/origin/HEAD","hash":"0cdba19acd8d1e1590ad867e4aa0ae25d52b09b3","modified":1535432555257},{"_id":"themes/miho/.git/objects/pack/pack-9cc60fc72be4d61d4a6868ad87b5b14281de76cc.pack","hash":"50e4606aec988e36933e419ec6d62316fdfd6689","modified":1535432555219},{"_id":"source/_posts/Hexo.md","hash":"637bd629f393c3de8f2453c42fb0a383fa1f44ed","modified":1529913624000},{"_id":"source/_posts/dotnet-core.md","hash":"e95cd4f14f23c72bb54074564fcbd55b28929525","modified":1529913624000},{"_id":"source/_posts/docker.md","hash":"06e4dac88a6bad53fff4a0638bac711b8833e1d4","modified":1529913624000},{"_id":"source/_posts/redis-skip.jpg","hash":"c34478ac1d6cc1f70e5eeeed9b5eb80098a1974a","modified":1529913624000},{"_id":"source/_posts/redis.md","hash":"748514426858a941c03c8c4e6f9023c924f013cf","modified":1529913624000},{"_id":"public/archives/index.html","hash":"a1f17e6c9426c65ad08223b166228f807bbe90c3","modified":1537235614068},{"_id":"public/archives/2018/index.html","hash":"7eb34e417da2d25fb0a846b75338ea2217bd8a2c","modified":1537235614082},{"_id":"public/archives/2018/04/index.html","hash":"c5be86f6a4172583d04add6d80e5e45c17436613","modified":1537235614083},{"_id":"public/archives/2018/08/index.html","hash":"09f27eadb5e00234c72a127f48d2f04b15e1235a","modified":1537235614084},{"_id":"public/index.html","hash":"24d38547b1ecfa0a641623e11e58878182b51123","modified":1537235614084},{"_id":"public/2018/08/28/dotnet-core/index.html","hash":"010577a83da5d5969dc808466c03ac4293bb1ecc","modified":1537235614085},{"_id":"public/2018/08/28/hello-world/index.html","hash":"3eab22bb6ed936150de733a9b22238e06143fd73","modified":1535467736825},{"_id":"public/2018/04/19/Hexo/index.html","hash":"835d4867293d06d8240c22e5c461565fef7e01b1","modified":1537235614085},{"_id":"public/2018/04/15/docker/index.html","hash":"1f9af4ebdbfe2acc674a0ab471509b291bed6ee5","modified":1535467736825},{"_id":"public/2018/04/10/redis/index.html","hash":"770517500111abf4e71510070c7ed217b722e7d8","modified":1535467736825},{"_id":"public/tags/备忘/index.html","hash":"e57cc92a95a5fb072fbf1cead83dfbd043f985e3","modified":1537235614084},{"_id":"public/favicon.ico","hash":"35e86b04bcdeeec0cabdee2e968db69aa8202788","modified":1535467736859},{"_id":"public/images/alipay.png","hash":"b3f9db844b1e522fc55125302f2979f50a6d0529","modified":1535467736859},{"_id":"public/images/alipay_code.jpg","hash":"3b328818714af7fbf7b20748d783c861d876fd5b","modified":1535467736859},{"_id":"public/images/logo.png","hash":"f1d5d676b78b087ba2a1f177f7ca949c4c8296e4","modified":1535467736859},{"_id":"public/images/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1535467736859},{"_id":"public/images/wechat.png","hash":"8de97bf5bb3f3a0845e02172f79d6bba2fb6bb3b","modified":1535467736860},{"_id":"public/images/wechat_code.jpg","hash":"4a5d67c6aed4a266ab0ddac7488361cfa01cf694","modified":1535467736860},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1535467736860},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1535467736860},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1535467736860},{"_id":"public/images/banner.jpg","hash":"e1d7853fb02b68ee6adcc2d9b3ca647bc802e9a9","modified":1535467737678},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1535467737680},{"_id":"public/js/animate.js","hash":"d5cf7dc4ad33b02bea74bb76d3eba85b67e907ce","modified":1535467737682},{"_id":"public/js/main.js","hash":"cae44d65bd63b29a749fcf43cea26d3b0cb8b2ef","modified":1535467737682},{"_id":"public/js/particles.js","hash":"8009af99d913d8c40509efaecfa5e56cefefbf0d","modified":1535467737682},{"_id":"public/js/pace.min.js","hash":"d32ab818e0f97d3b0c80f5631fc23d8a0cb52795","modified":1535467737682},{"_id":"public/js/pop-img.js","hash":"8e638e492b9699da1b9ca22d9f74a6578712925a","modified":1535467737682},{"_id":"public/js/search.js","hash":"ae4b06fd09a090a5388fd880bba919a1c0c64dd3","modified":1535467737683},{"_id":"public/css/style.css","hash":"1ad2595794ce85c93e0206a249a9242591102b36","modified":1535467737683},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1535467737685},{"_id":"source/_posts/hangfire.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537235552445},{"_id":"public/2018/09/18/hangfire/index.html","hash":"598d7d90a28a319289a092d0040b5e1c6377c143","modified":1537235614085},{"_id":"public/archives/2018/09/index.html","hash":"13459312cd5976e116385a6bae5a6f51ce0abc1f","modified":1537235614085}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Hexo基础","date":"2018-04-19T09:53:21.000Z","_content":"\n### 基础\n- 依赖\n    - node.js\n    - git\n    - nginx\n- 安装\n```\nnpm install -g hexo-cli #全局安装\n```\n- 初始化\n```\nhexo init [folder] # 在当前目录下的创建初始化文件\n```\n- 文件结构\n```\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n- 安装依赖\n```\ncd [folder]\nnpm i\n```\n- _config.yml（网站基本信息配置）[详细](https://hexo.io/zh-cn/docs/configuration.html)\n\n参数 | 描述\n---|---\ntitle   |\t网站标题\nsubtitle   |\t网站副标题\ndescription   |\t网站描述\nauthor   |\t您的名字\nlanguage   |\t网站使用的语言\ntimezone   |\t网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。\n- 新建文章\n```\nhexo new [layout] <title>\n# 创建的文章在 hexo 的初始化目录下的 source/_posts\n```\n新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。\n- 构建\n```\nhexo g\n```\n- 等同于\n```\nhexo generate\n```\n参数 | 描述\n---|---\n-d, --deploy |\t文件生成后立即部署网站\n-w, --watch\t| 监视文件变动\n\n- 预览\n```\nhexo server\n```\n参数 | 描述\n---|---\n-p, --port |\t重设端口 ，默认 4000\n-s, --static |\t只使用静态文件\n-l, --log |\t启动日记记录，使用覆盖记录格式\n- 发布到静态文件\n\n- \n\n- [主题](http://theme-next.iissnan.com/)\n    - [主题预览](https://github.com/iissnan/hexo-theme-next/blob/master/README.cn.md)\n- 参考\n    - [官网](https://hexo.io/)","source":"_posts/Hexo.md","raw":"---\ntitle: Hexo基础\ndate: 2018-04-19 17:53:21\ntags: 备忘\n---\n\n### 基础\n- 依赖\n    - node.js\n    - git\n    - nginx\n- 安装\n```\nnpm install -g hexo-cli #全局安装\n```\n- 初始化\n```\nhexo init [folder] # 在当前目录下的创建初始化文件\n```\n- 文件结构\n```\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n- 安装依赖\n```\ncd [folder]\nnpm i\n```\n- _config.yml（网站基本信息配置）[详细](https://hexo.io/zh-cn/docs/configuration.html)\n\n参数 | 描述\n---|---\ntitle   |\t网站标题\nsubtitle   |\t网站副标题\ndescription   |\t网站描述\nauthor   |\t您的名字\nlanguage   |\t网站使用的语言\ntimezone   |\t网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。\n- 新建文章\n```\nhexo new [layout] <title>\n# 创建的文章在 hexo 的初始化目录下的 source/_posts\n```\n新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。\n- 构建\n```\nhexo g\n```\n- 等同于\n```\nhexo generate\n```\n参数 | 描述\n---|---\n-d, --deploy |\t文件生成后立即部署网站\n-w, --watch\t| 监视文件变动\n\n- 预览\n```\nhexo server\n```\n参数 | 描述\n---|---\n-p, --port |\t重设端口 ，默认 4000\n-s, --static |\t只使用静态文件\n-l, --log |\t启动日记记录，使用覆盖记录格式\n- 发布到静态文件\n\n- \n\n- [主题](http://theme-next.iissnan.com/)\n    - [主题预览](https://github.com/iissnan/hexo-theme-next/blob/master/README.cn.md)\n- 参考\n    - [官网](https://hexo.io/)","slug":"Hexo","published":1,"updated":"2018-06-25T08:00:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjldtqr5p0000ewude5mri1gb","content":"<h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><ul>\n<li>依赖<ul>\n<li>node.js</li>\n<li>git</li>\n<li>nginx</li>\n</ul>\n</li>\n<li><p>安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli #全局安装</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>初始化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init [folder] # 在当前目录下的创建初始化文件</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>文件结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd [folder]</span><br><span class=\"line\">npm i</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>_config.yml（网站基本信息配置）<a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">详细</a></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>title</td>\n<td>网站标题</td>\n</tr>\n<tr>\n<td>subtitle</td>\n<td>网站副标题</td>\n</tr>\n<tr>\n<td>description</td>\n<td>网站描述</td>\n</tr>\n<tr>\n<td>author</td>\n<td>您的名字</td>\n</tr>\n<tr>\n<td>language</td>\n<td>网站使用的语言</td>\n</tr>\n<tr>\n<td>timezone</td>\n<td>网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>新建文章<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new [layout] &lt;title&gt;</span><br><span class=\"line\"># 创建的文章在 hexo 的初始化目录下的 source/_posts</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p>\n<ul>\n<li><p>构建</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>等同于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-d, –deploy</td>\n<td>文件生成后立即部署网站</td>\n</tr>\n<tr>\n<td>-w, –watch</td>\n<td>监视文件变动</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>预览<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-p, –port</td>\n<td>重设端口 ，默认 4000</td>\n</tr>\n<tr>\n<td>-s, –static</td>\n<td>只使用静态文件</td>\n</tr>\n<tr>\n<td>-l, –log</td>\n<td>启动日记记录，使用覆盖记录格式</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>发布到静态文件</p>\n</li>\n<li></li>\n<li><p><a href=\"http://theme-next.iissnan.com/\" target=\"_blank\" rel=\"noopener\">主题</a></p>\n<ul>\n<li><a href=\"https://github.com/iissnan/hexo-theme-next/blob/master/README.cn.md\" target=\"_blank\" rel=\"noopener\">主题预览</a></li>\n</ul>\n</li>\n<li>参考<ul>\n<li><a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">官网</a></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><ul>\n<li>依赖<ul>\n<li>node.js</li>\n<li>git</li>\n<li>nginx</li>\n</ul>\n</li>\n<li><p>安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli #全局安装</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>初始化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init [folder] # 在当前目录下的创建初始化文件</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>文件结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd [folder]</span><br><span class=\"line\">npm i</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>_config.yml（网站基本信息配置）<a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">详细</a></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>title</td>\n<td>网站标题</td>\n</tr>\n<tr>\n<td>subtitle</td>\n<td>网站副标题</td>\n</tr>\n<tr>\n<td>description</td>\n<td>网站描述</td>\n</tr>\n<tr>\n<td>author</td>\n<td>您的名字</td>\n</tr>\n<tr>\n<td>language</td>\n<td>网站使用的语言</td>\n</tr>\n<tr>\n<td>timezone</td>\n<td>网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>新建文章<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new [layout] &lt;title&gt;</span><br><span class=\"line\"># 创建的文章在 hexo 的初始化目录下的 source/_posts</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p>\n<ul>\n<li><p>构建</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>等同于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-d, –deploy</td>\n<td>文件生成后立即部署网站</td>\n</tr>\n<tr>\n<td>-w, –watch</td>\n<td>监视文件变动</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>预览<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-p, –port</td>\n<td>重设端口 ，默认 4000</td>\n</tr>\n<tr>\n<td>-s, –static</td>\n<td>只使用静态文件</td>\n</tr>\n<tr>\n<td>-l, –log</td>\n<td>启动日记记录，使用覆盖记录格式</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>发布到静态文件</p>\n</li>\n<li></li>\n<li><p><a href=\"http://theme-next.iissnan.com/\" target=\"_blank\" rel=\"noopener\">主题</a></p>\n<ul>\n<li><a href=\"https://github.com/iissnan/hexo-theme-next/blob/master/README.cn.md\" target=\"_blank\" rel=\"noopener\">主题预览</a></li>\n</ul>\n</li>\n<li>参考<ul>\n<li><a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">官网</a></li>\n</ul>\n</li>\n</ul>\n"},{"title":"dotnet core","date":"2018-08-28T14:45:46.768Z","_content":"\n### 安装\n- [在Ubuntu上安装](https://www.microsoft.com/net/download/linux-package-manager/ubuntu16-04/sdk-current)\n- 其他 (todo)\n---\n### Build\n- 编译当前目录下的代码\n```\ndotnet build \n```\n- 以生产环境编译当前目录下的代码，且指定输出（相对）路径\n```\ndotnet publish -c Release -o bin/Release/PublishOutput\n```\n---\n### Config\n- 使用ConfigurationBuilder来注入生成配置文件\n```C#\npublic static T GetConfigJson<T>(string key, string fileName = \"appsettings.json\") where T : class, new()\n{\n    var builder = new ConfigurationBuilder()\n   .SetBasePath(Directory.GetCurrentDirectory())\n   .AddJsonFile(fileName);\n    var config = builder.Build();\n\n    var entity = new T();\n    config.GetSection(key).Bind(entity);\n    return entity;\n}\n\npublic static string GetAppSetting(string key, string fileName= \"appsettings.json\")\n{\n    var builder = new ConfigurationBuilder()\n   .SetBasePath(Directory.GetCurrentDirectory())\n   .AddJsonFile(fileName);\n    var config = builder.Build();\n\n    return config.GetSection(key).Value;\n}\n```\n- 有些时候我们需要自定义配置文件，那么我们需要将配置文件也编译到对应的目录\n```xml\n  <ItemGroup>\n    <None Update=\"Config\\appsettings.json\">\n      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>\n    </None>\n  </ItemGroup>\n```\n","source":"_posts/dotnet-core.md","raw":"---\ntitle: dotnet core \ndate: 2018年6月25日\ntags: 备忘\n---\n\n### 安装\n- [在Ubuntu上安装](https://www.microsoft.com/net/download/linux-package-manager/ubuntu16-04/sdk-current)\n- 其他 (todo)\n---\n### Build\n- 编译当前目录下的代码\n```\ndotnet build \n```\n- 以生产环境编译当前目录下的代码，且指定输出（相对）路径\n```\ndotnet publish -c Release -o bin/Release/PublishOutput\n```\n---\n### Config\n- 使用ConfigurationBuilder来注入生成配置文件\n```C#\npublic static T GetConfigJson<T>(string key, string fileName = \"appsettings.json\") where T : class, new()\n{\n    var builder = new ConfigurationBuilder()\n   .SetBasePath(Directory.GetCurrentDirectory())\n   .AddJsonFile(fileName);\n    var config = builder.Build();\n\n    var entity = new T();\n    config.GetSection(key).Bind(entity);\n    return entity;\n}\n\npublic static string GetAppSetting(string key, string fileName= \"appsettings.json\")\n{\n    var builder = new ConfigurationBuilder()\n   .SetBasePath(Directory.GetCurrentDirectory())\n   .AddJsonFile(fileName);\n    var config = builder.Build();\n\n    return config.GetSection(key).Value;\n}\n```\n- 有些时候我们需要自定义配置文件，那么我们需要将配置文件也编译到对应的目录\n```xml\n  <ItemGroup>\n    <None Update=\"Config\\appsettings.json\">\n      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>\n    </None>\n  </ItemGroup>\n```\n","slug":"dotnet-core","published":1,"updated":"2018-06-25T08:00:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjldtqr5y0001ewudhouxo3sa","content":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><ul>\n<li><a href=\"https://www.microsoft.com/net/download/linux-package-manager/ubuntu16-04/sdk-current\" target=\"_blank\" rel=\"noopener\">在Ubuntu上安装</a></li>\n<li>其他 (todo)</li>\n</ul>\n<hr>\n<h3 id=\"Build\"><a href=\"#Build\" class=\"headerlink\" title=\"Build\"></a>Build</h3><ul>\n<li><p>编译当前目录下的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dotnet build</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>以生产环境编译当前目录下的代码，且指定输出（相对）路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dotnet publish -c Release -o bin/Release/PublishOutput</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"Config\"><a href=\"#Config\" class=\"headerlink\" title=\"Config\"></a>Config</h3><ul>\n<li><p>使用ConfigurationBuilder来注入生成配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static T GetConfigJson&lt;T&gt;(string key, string fileName = &quot;appsettings.json&quot;) where T : class, new()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var builder = new ConfigurationBuilder()</span><br><span class=\"line\">   .SetBasePath(Directory.GetCurrentDirectory())</span><br><span class=\"line\">   .AddJsonFile(fileName);</span><br><span class=\"line\">    var config = builder.Build();</span><br><span class=\"line\"></span><br><span class=\"line\">    var entity = new T();</span><br><span class=\"line\">    config.GetSection(key).Bind(entity);</span><br><span class=\"line\">    return entity;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static string GetAppSetting(string key, string fileName= &quot;appsettings.json&quot;)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var builder = new ConfigurationBuilder()</span><br><span class=\"line\">   .SetBasePath(Directory.GetCurrentDirectory())</span><br><span class=\"line\">   .AddJsonFile(fileName);</span><br><span class=\"line\">    var config = builder.Build();</span><br><span class=\"line\"></span><br><span class=\"line\">    return config.GetSection(key).Value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>有些时候我们需要自定义配置文件，那么我们需要将配置文件也编译到对应的目录</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ItemGroup</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">None</span> <span class=\"attr\">Update</span>=<span class=\"string\">\"Config\\appsettings.json\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">CopyToOutputDirectory</span>&gt;</span>PreserveNewest<span class=\"tag\">&lt;/<span class=\"name\">CopyToOutputDirectory</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">None</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ItemGroup</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><ul>\n<li><a href=\"https://www.microsoft.com/net/download/linux-package-manager/ubuntu16-04/sdk-current\" target=\"_blank\" rel=\"noopener\">在Ubuntu上安装</a></li>\n<li>其他 (todo)</li>\n</ul>\n<hr>\n<h3 id=\"Build\"><a href=\"#Build\" class=\"headerlink\" title=\"Build\"></a>Build</h3><ul>\n<li><p>编译当前目录下的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dotnet build</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>以生产环境编译当前目录下的代码，且指定输出（相对）路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dotnet publish -c Release -o bin/Release/PublishOutput</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"Config\"><a href=\"#Config\" class=\"headerlink\" title=\"Config\"></a>Config</h3><ul>\n<li><p>使用ConfigurationBuilder来注入生成配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static T GetConfigJson&lt;T&gt;(string key, string fileName = &quot;appsettings.json&quot;) where T : class, new()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var builder = new ConfigurationBuilder()</span><br><span class=\"line\">   .SetBasePath(Directory.GetCurrentDirectory())</span><br><span class=\"line\">   .AddJsonFile(fileName);</span><br><span class=\"line\">    var config = builder.Build();</span><br><span class=\"line\"></span><br><span class=\"line\">    var entity = new T();</span><br><span class=\"line\">    config.GetSection(key).Bind(entity);</span><br><span class=\"line\">    return entity;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static string GetAppSetting(string key, string fileName= &quot;appsettings.json&quot;)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var builder = new ConfigurationBuilder()</span><br><span class=\"line\">   .SetBasePath(Directory.GetCurrentDirectory())</span><br><span class=\"line\">   .AddJsonFile(fileName);</span><br><span class=\"line\">    var config = builder.Build();</span><br><span class=\"line\"></span><br><span class=\"line\">    return config.GetSection(key).Value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>有些时候我们需要自定义配置文件，那么我们需要将配置文件也编译到对应的目录</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ItemGroup</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">None</span> <span class=\"attr\">Update</span>=<span class=\"string\">\"Config\\appsettings.json\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">CopyToOutputDirectory</span>&gt;</span>PreserveNewest<span class=\"tag\">&lt;/<span class=\"name\">CopyToOutputDirectory</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">None</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ItemGroup</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"docker基础","date":"2018-04-15T07:28:47.000Z","_content":"\n### 基本命令\n- `docker pull [imagename]`(获取远程镜像)\n- `docker images` (显示全部本地images)\n- `docker ps -a`(显示本地container)\n- `docker rm [ID]` (移除本地container)\n- `docker stop [ID]` (停止容器)\n- `docker rmi [ID]` (移除本地image)\n- `docker build -t [Image] .`(使用本地的Dockerfile构建自己的image, 别忘记结束的那个点\" . \")\n- `docker run -d -p [port]:[port] [ image]`  (-d 后台运行返回容器Id， -p指定端口映射到宿主的端口 )\n- `docker tag [old] [new]` (为image 签名, 签名的内容是: hubdockerId/imageName)\n- `docker push [image]` (image 必须为签名后的imageName)\n\n- docker exec -it [ID] bash  (使用正在运行的容器的命令行)\n\n### Dockerfile\n- 选用远程镜像\n`FROM [远程镜像]`\n- 复制本地文件到镜像中 \n`COPY [复制的本地路径]  [被复制image路径]`    \n- 工作目录\n`WORKDIR /app`\n- 项目启动之前可以运行一些命令\n`RUN [xxx xxx-xxx]`\n- 项目入口\n`ENTRYPOINT [\"dotnet\", \"[程序入口文件]\"]`\n\n参考\n\n- docker 命令大全 \n  - http://www.runoob.com/docker/docker-command-manual.html\n- Dockerfile 语法详解\n  - https://www.jianshu.com/p/690844302df5\n- ENTRYPOINT 具体用法\n  - todo\n","source":"_posts/docker.md","raw":"---\ntitle: docker基础\ndate: 2018-04-15 15:28:47\ntags: 备忘\n---\n\n### 基本命令\n- `docker pull [imagename]`(获取远程镜像)\n- `docker images` (显示全部本地images)\n- `docker ps -a`(显示本地container)\n- `docker rm [ID]` (移除本地container)\n- `docker stop [ID]` (停止容器)\n- `docker rmi [ID]` (移除本地image)\n- `docker build -t [Image] .`(使用本地的Dockerfile构建自己的image, 别忘记结束的那个点\" . \")\n- `docker run -d -p [port]:[port] [ image]`  (-d 后台运行返回容器Id， -p指定端口映射到宿主的端口 )\n- `docker tag [old] [new]` (为image 签名, 签名的内容是: hubdockerId/imageName)\n- `docker push [image]` (image 必须为签名后的imageName)\n\n- docker exec -it [ID] bash  (使用正在运行的容器的命令行)\n\n### Dockerfile\n- 选用远程镜像\n`FROM [远程镜像]`\n- 复制本地文件到镜像中 \n`COPY [复制的本地路径]  [被复制image路径]`    \n- 工作目录\n`WORKDIR /app`\n- 项目启动之前可以运行一些命令\n`RUN [xxx xxx-xxx]`\n- 项目入口\n`ENTRYPOINT [\"dotnet\", \"[程序入口文件]\"]`\n\n参考\n\n- docker 命令大全 \n  - http://www.runoob.com/docker/docker-command-manual.html\n- Dockerfile 语法详解\n  - https://www.jianshu.com/p/690844302df5\n- ENTRYPOINT 具体用法\n  - todo\n","slug":"docker","published":1,"updated":"2018-06-25T08:00:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjldtqr670003ewud8utfo9cp","content":"<h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><ul>\n<li><code>docker pull [imagename]</code>(获取远程镜像)</li>\n<li><code>docker images</code> (显示全部本地images)</li>\n<li><code>docker ps -a</code>(显示本地container)</li>\n<li><code>docker rm [ID]</code> (移除本地container)</li>\n<li><code>docker stop [ID]</code> (停止容器)</li>\n<li><code>docker rmi [ID]</code> (移除本地image)</li>\n<li><code>docker build -t [Image] .</code>(使用本地的Dockerfile构建自己的image, 别忘记结束的那个点” . “)</li>\n<li><code>docker run -d -p [port]:[port] [ image]</code>  (-d 后台运行返回容器Id， -p指定端口映射到宿主的端口 )</li>\n<li><code>docker tag [old] [new]</code> (为image 签名, 签名的内容是: hubdockerId/imageName)</li>\n<li><p><code>docker push [image]</code> (image 必须为签名后的imageName)</p>\n</li>\n<li><p>docker exec -it [ID] bash  (使用正在运行的容器的命令行)</p>\n</li>\n</ul>\n<h3 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h3><ul>\n<li>选用远程镜像<br><code>FROM [远程镜像]</code></li>\n<li>复制本地文件到镜像中<br><code>COPY [复制的本地路径]  [被复制image路径]</code>    </li>\n<li>工作目录<br><code>WORKDIR /app</code></li>\n<li>项目启动之前可以运行一些命令<br><code>RUN [xxx xxx-xxx]</code></li>\n<li>项目入口<br><code>ENTRYPOINT [&quot;dotnet&quot;, &quot;[程序入口文件]&quot;]</code></li>\n</ul>\n<p>参考</p>\n<ul>\n<li>docker 命令大全 <ul>\n<li><a href=\"http://www.runoob.com/docker/docker-command-manual.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/docker/docker-command-manual.html</a></li>\n</ul>\n</li>\n<li>Dockerfile 语法详解<ul>\n<li><a href=\"https://www.jianshu.com/p/690844302df5\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/690844302df5</a></li>\n</ul>\n</li>\n<li>ENTRYPOINT 具体用法<ul>\n<li>todo</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><ul>\n<li><code>docker pull [imagename]</code>(获取远程镜像)</li>\n<li><code>docker images</code> (显示全部本地images)</li>\n<li><code>docker ps -a</code>(显示本地container)</li>\n<li><code>docker rm [ID]</code> (移除本地container)</li>\n<li><code>docker stop [ID]</code> (停止容器)</li>\n<li><code>docker rmi [ID]</code> (移除本地image)</li>\n<li><code>docker build -t [Image] .</code>(使用本地的Dockerfile构建自己的image, 别忘记结束的那个点” . “)</li>\n<li><code>docker run -d -p [port]:[port] [ image]</code>  (-d 后台运行返回容器Id， -p指定端口映射到宿主的端口 )</li>\n<li><code>docker tag [old] [new]</code> (为image 签名, 签名的内容是: hubdockerId/imageName)</li>\n<li><p><code>docker push [image]</code> (image 必须为签名后的imageName)</p>\n</li>\n<li><p>docker exec -it [ID] bash  (使用正在运行的容器的命令行)</p>\n</li>\n</ul>\n<h3 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h3><ul>\n<li>选用远程镜像<br><code>FROM [远程镜像]</code></li>\n<li>复制本地文件到镜像中<br><code>COPY [复制的本地路径]  [被复制image路径]</code>    </li>\n<li>工作目录<br><code>WORKDIR /app</code></li>\n<li>项目启动之前可以运行一些命令<br><code>RUN [xxx xxx-xxx]</code></li>\n<li>项目入口<br><code>ENTRYPOINT [&quot;dotnet&quot;, &quot;[程序入口文件]&quot;]</code></li>\n</ul>\n<p>参考</p>\n<ul>\n<li>docker 命令大全 <ul>\n<li><a href=\"http://www.runoob.com/docker/docker-command-manual.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/docker/docker-command-manual.html</a></li>\n</ul>\n</li>\n<li>Dockerfile 语法详解<ul>\n<li><a href=\"https://www.jianshu.com/p/690844302df5\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/690844302df5</a></li>\n</ul>\n</li>\n<li>ENTRYPOINT 具体用法<ul>\n<li>todo</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Redis 基础","date":"2018-04-09T16:00:00.000Z","_content":"---\ndate：2018年4月19日\n---\n\n\n### 源码安装 \n- 下载\n```\n wget http://download.redis.io/releases/redis-stable.tar.gz\n```\n- 解压\n```\ntar -xzvf redis-stable.tar.gz\nmv redis-stable redis\n```\n- 编译\n```\ncd redis\nmake\n```\n- 修改配置reids.conf\n```\nbind 127.0.0.1 --> 0.0.0.0 # 运行远程访问\ndaemonize no --> yes # 后台运行\ndatabase 16 # 库的数量\n```\n- 启动\n```\nsrc/redis-server redis.conf\n```\n- 停止\n```\nsrc/redis-cli \nshutdown\nexit\n```\n\n---\n\n### apt \n- 安装\n```\napt-get install redis-server\n# 安装完成就直接启动了, 默认读取的配置文件在/etc/redis/redis.conf\n```\n- 停止\n```\nsystemctl stop redis-server\n```\n \n---\n  \n### Docker\n- 基本命令\n```\ndocker pull redis \ndocker run -p 6380:6379 redis # 运行redis镜像映射到主机的6380端口\ndocker sp -a # 查看容器运行状态\ndocker start xx # 启动\ndocker restart xx # 重启容器\ndocker stop xx # 停止\n```\n- 使用自定义的配置文件[（完整的配置描述）](https://raw.githubusercontent.com/antirez/redis/8ac7af1c5d4d06d6c165e35d67a3a6a70e5d98c3/redis.conf)\n```\ndocker run -v /home/ubuntu/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 redis redis-server /usr/local/etc/redis/redis.conf\n// 注意修改配置中的数据库文件路径 如：dir ./\n```\n\n\n---\n\n### 常用数据结构\n- [Strng](http://redisdoc.com/string/index.html)\n\n- [Hash](http://redisdoc.com/hash/index.html)\n\n- [List](http://redisdoc.com/list/index.html)\n\n- [Set](http://redisdoc.com/set/index.html)\n\n- [SortedSet](http://redisdoc.com/sorted_set/index.html)\n\n---\n\n### 订阅 & 发布\n- 所有的订阅都是全局的。\n- 当你为一个渠道多次订阅时，这个渠道的每次消息发布，会收到多条订阅。\n- 订阅的消息可以是呈队列有序，也可以是并行的\n\n---\n\n### 事务 \n- redis 不支持回滚\n- 事务是用来保证即使你有命令的连续执行，在多并发的情况下，希望几条命令是联系执行的时候使用事务。\n- 事务中的多条命令中有一条或者以上的命令存在语法错误，那么正确的命令即使是 `EXEC` 也不会被执行 *（在Redis 2.6.5之后）* 。但是需要注意的是这种错误的事务机制仅限于语法错误。\n- `DISCARD` 用来放弃事务, 在执行到 `DISCARD` 的时候全部的命令将被放弃。如果正在使用 `WATCH` 命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 `UNWATCH` 。\n- `WATCH` 命令可以为 Redis 事务提供 check-and-set 行为。\n被 `WATCH` 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消，set执行失败。\n- [如何在C#中使用事务](https://github.com/sc1994/.NET-Learn/blob/master/Redis/RedisDemo/Transactions%20in%20Redis.md)(使用StackExchange.Redis)\n\n---\n\n### Redis 集群\n- Redis 集群是一个分布式（distributed）、容错（fault-tolerant）的 Redis 实现， 集群可以使用的功能是普通单机 Redis 所能使用的功能的一个子集（subset）。\n- Redis 集群中不存在中心（central）节点或者代理（proxy）节点， 集群的其中一个主要设计目标是达到线性可扩展性（linear scalability）。\n- Redis 集群为了保证一致性（consistency）而牺牲了一部分容错性： 系统会在保证对网络断线（net split）和节点失效（node failure）具有有限抵抗力的前提下， 尽可能地保持数据的一致性。\n\n---\n\n### 索引\n- 跳跃表\n```\n在跳跃表是由N层链表组成，最底层是最完整的的数据，每次数据插入，率先进入到这个链表（有序的），\n插入完成后，通过抛硬币的算法，判断是否将数据向上层跑，如果是1的话，就抛到上层，然后继续抛硬盘，\n判断是否继续向上层抛，直到抛出了0结束整个操作，每抛到一层的时候，如果当前层没有数据，就构造一个链表，\n将数据放进去，然后使用指针指向来源地址，就这样依次类推，形成了跳跃表，每次查询，从最上层遍历查询，\n如果找到就返回结果，否则就在此层找到最接近查询的值，将查询操作移到另外一层，就是刚才说到来源地址，\n所在层，重复查询。\n```\n![image](http://118.24.27.231:8088/v2-114f4895c296861aca549d96fc4b563f_r.jpg)\n\n- 单线程\n```\n单线程的模式解决了数据存储的顽疾：数据并发安全，任何运行多线程同时访问数据库都会存在这个问题。\n所以才有了mysql的mvcc和锁， Memcached 的cas 乐观锁，来保证数据不会出现并发导致的数据问题。\n但是redis 使用单线程就不存在这个问题：\n    1：单线程足够简单，无论在redis的实现还是作为调用方，都不需要为数据并发提心吊胆，不需要加锁。\n    2：不会出现不必要的线程调度，你知道多线程，频繁切换上下文，也会带来很多性能消耗。\n```\n\n- 多路 I/O 复用模型\n```\n多路 I/O 复用模型，这个也是java 的NIO体系使用的IO模型，也是linux诸多IO模型中的一种。\n说白了就是当一个请求来访问redis后，redis去组织数据要返回给请求，这个时间段，redis的请求入口不是阻塞的。\n其他请求可以继续向redis发送请求，等到redis io流完成后，再向调用者返回数据。\n这样一来，单线程也不怕会影响速度了。\n```\n---\n\n### 缓存击穿\n- 什么是缓存击穿\n```\n缓存一般作为RDS的前置系统和服务器直连，减轻rds的负担，常理而言。\n如果服务器查询缓存而不得的话，需要从rds中获取然后更新到缓存中，但是如果在“从rds中获取然后更新到缓存中”，\n这个阶段，缓存尚未更新成功，大量请求进来的话，rds势必压力暴增，甚至雪崩，或者歹人恶意攻击，\n一直查询rds和缓存中未存在key，也会导致缓存机制失效，rds压力暴增，称之为缓存击穿\n```\n","source":"_posts/redis.md","raw":"---\ntitle: Redis 基础\ndate: 2018-04-10\ntags: 备忘\n---\n---\ndate：2018年4月19日\n---\n\n\n### 源码安装 \n- 下载\n```\n wget http://download.redis.io/releases/redis-stable.tar.gz\n```\n- 解压\n```\ntar -xzvf redis-stable.tar.gz\nmv redis-stable redis\n```\n- 编译\n```\ncd redis\nmake\n```\n- 修改配置reids.conf\n```\nbind 127.0.0.1 --> 0.0.0.0 # 运行远程访问\ndaemonize no --> yes # 后台运行\ndatabase 16 # 库的数量\n```\n- 启动\n```\nsrc/redis-server redis.conf\n```\n- 停止\n```\nsrc/redis-cli \nshutdown\nexit\n```\n\n---\n\n### apt \n- 安装\n```\napt-get install redis-server\n# 安装完成就直接启动了, 默认读取的配置文件在/etc/redis/redis.conf\n```\n- 停止\n```\nsystemctl stop redis-server\n```\n \n---\n  \n### Docker\n- 基本命令\n```\ndocker pull redis \ndocker run -p 6380:6379 redis # 运行redis镜像映射到主机的6380端口\ndocker sp -a # 查看容器运行状态\ndocker start xx # 启动\ndocker restart xx # 重启容器\ndocker stop xx # 停止\n```\n- 使用自定义的配置文件[（完整的配置描述）](https://raw.githubusercontent.com/antirez/redis/8ac7af1c5d4d06d6c165e35d67a3a6a70e5d98c3/redis.conf)\n```\ndocker run -v /home/ubuntu/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 redis redis-server /usr/local/etc/redis/redis.conf\n// 注意修改配置中的数据库文件路径 如：dir ./\n```\n\n\n---\n\n### 常用数据结构\n- [Strng](http://redisdoc.com/string/index.html)\n\n- [Hash](http://redisdoc.com/hash/index.html)\n\n- [List](http://redisdoc.com/list/index.html)\n\n- [Set](http://redisdoc.com/set/index.html)\n\n- [SortedSet](http://redisdoc.com/sorted_set/index.html)\n\n---\n\n### 订阅 & 发布\n- 所有的订阅都是全局的。\n- 当你为一个渠道多次订阅时，这个渠道的每次消息发布，会收到多条订阅。\n- 订阅的消息可以是呈队列有序，也可以是并行的\n\n---\n\n### 事务 \n- redis 不支持回滚\n- 事务是用来保证即使你有命令的连续执行，在多并发的情况下，希望几条命令是联系执行的时候使用事务。\n- 事务中的多条命令中有一条或者以上的命令存在语法错误，那么正确的命令即使是 `EXEC` 也不会被执行 *（在Redis 2.6.5之后）* 。但是需要注意的是这种错误的事务机制仅限于语法错误。\n- `DISCARD` 用来放弃事务, 在执行到 `DISCARD` 的时候全部的命令将被放弃。如果正在使用 `WATCH` 命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 `UNWATCH` 。\n- `WATCH` 命令可以为 Redis 事务提供 check-and-set 行为。\n被 `WATCH` 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消，set执行失败。\n- [如何在C#中使用事务](https://github.com/sc1994/.NET-Learn/blob/master/Redis/RedisDemo/Transactions%20in%20Redis.md)(使用StackExchange.Redis)\n\n---\n\n### Redis 集群\n- Redis 集群是一个分布式（distributed）、容错（fault-tolerant）的 Redis 实现， 集群可以使用的功能是普通单机 Redis 所能使用的功能的一个子集（subset）。\n- Redis 集群中不存在中心（central）节点或者代理（proxy）节点， 集群的其中一个主要设计目标是达到线性可扩展性（linear scalability）。\n- Redis 集群为了保证一致性（consistency）而牺牲了一部分容错性： 系统会在保证对网络断线（net split）和节点失效（node failure）具有有限抵抗力的前提下， 尽可能地保持数据的一致性。\n\n---\n\n### 索引\n- 跳跃表\n```\n在跳跃表是由N层链表组成，最底层是最完整的的数据，每次数据插入，率先进入到这个链表（有序的），\n插入完成后，通过抛硬币的算法，判断是否将数据向上层跑，如果是1的话，就抛到上层，然后继续抛硬盘，\n判断是否继续向上层抛，直到抛出了0结束整个操作，每抛到一层的时候，如果当前层没有数据，就构造一个链表，\n将数据放进去，然后使用指针指向来源地址，就这样依次类推，形成了跳跃表，每次查询，从最上层遍历查询，\n如果找到就返回结果，否则就在此层找到最接近查询的值，将查询操作移到另外一层，就是刚才说到来源地址，\n所在层，重复查询。\n```\n![image](http://118.24.27.231:8088/v2-114f4895c296861aca549d96fc4b563f_r.jpg)\n\n- 单线程\n```\n单线程的模式解决了数据存储的顽疾：数据并发安全，任何运行多线程同时访问数据库都会存在这个问题。\n所以才有了mysql的mvcc和锁， Memcached 的cas 乐观锁，来保证数据不会出现并发导致的数据问题。\n但是redis 使用单线程就不存在这个问题：\n    1：单线程足够简单，无论在redis的实现还是作为调用方，都不需要为数据并发提心吊胆，不需要加锁。\n    2：不会出现不必要的线程调度，你知道多线程，频繁切换上下文，也会带来很多性能消耗。\n```\n\n- 多路 I/O 复用模型\n```\n多路 I/O 复用模型，这个也是java 的NIO体系使用的IO模型，也是linux诸多IO模型中的一种。\n说白了就是当一个请求来访问redis后，redis去组织数据要返回给请求，这个时间段，redis的请求入口不是阻塞的。\n其他请求可以继续向redis发送请求，等到redis io流完成后，再向调用者返回数据。\n这样一来，单线程也不怕会影响速度了。\n```\n---\n\n### 缓存击穿\n- 什么是缓存击穿\n```\n缓存一般作为RDS的前置系统和服务器直连，减轻rds的负担，常理而言。\n如果服务器查询缓存而不得的话，需要从rds中获取然后更新到缓存中，但是如果在“从rds中获取然后更新到缓存中”，\n这个阶段，缓存尚未更新成功，大量请求进来的话，rds势必压力暴增，甚至雪崩，或者歹人恶意攻击，\n一直查询rds和缓存中未存在key，也会导致缓存机制失效，rds压力暴增，称之为缓存击穿\n```\n","slug":"redis","published":1,"updated":"2018-06-25T08:00:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjldtqr7u0009ewud3ta9bliu","content":"<hr>\n<h2 id=\"date：2018年4月19日\"><a href=\"#date：2018年4月19日\" class=\"headerlink\" title=\"date：2018年4月19日\"></a>date：2018年4月19日</h2><h3 id=\"源码安装\"><a href=\"#源码安装\" class=\"headerlink\" title=\"源码安装\"></a>源码安装</h3><ul>\n<li><p>下载</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://download.redis.io/releases/redis-stable.tar.gz</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解压</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xzvf redis-stable.tar.gz</span><br><span class=\"line\">mv redis-stable redis</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd redis</span><br><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改配置reids.conf</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bind 127.0.0.1 --&gt; 0.0.0.0 # 运行远程访问</span><br><span class=\"line\">daemonize no --&gt; yes # 后台运行</span><br><span class=\"line\">database 16 # 库的数量</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src/redis-server redis.conf</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>停止</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src/redis-cli </span><br><span class=\"line\">shutdown</span><br><span class=\"line\">exit</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"apt\"><a href=\"#apt\" class=\"headerlink\" title=\"apt\"></a>apt</h3><ul>\n<li><p>安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install redis-server</span><br><span class=\"line\"># 安装完成就直接启动了, 默认读取的配置文件在/etc/redis/redis.conf</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>停止</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl stop redis-server</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h3><ul>\n<li><p>基本命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull redis </span><br><span class=\"line\">docker run -p 6380:6379 redis # 运行redis镜像映射到主机的6380端口</span><br><span class=\"line\">docker sp -a # 查看容器运行状态</span><br><span class=\"line\">docker start xx # 启动</span><br><span class=\"line\">docker restart xx # 重启容器</span><br><span class=\"line\">docker stop xx # 停止</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用自定义的配置文件<a href=\"https://raw.githubusercontent.com/antirez/redis/8ac7af1c5d4d06d6c165e35d67a3a6a70e5d98c3/redis.conf\" target=\"_blank\" rel=\"noopener\">（完整的配置描述）</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -v /home/ubuntu/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 redis redis-server /usr/local/etc/redis/redis.conf</span><br><span class=\"line\">// 注意修改配置中的数据库文件路径 如：dir ./</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"常用数据结构\"><a href=\"#常用数据结构\" class=\"headerlink\" title=\"常用数据结构\"></a>常用数据结构</h3><ul>\n<li><p><a href=\"http://redisdoc.com/string/index.html\" target=\"_blank\" rel=\"noopener\">Strng</a></p>\n</li>\n<li><p><a href=\"http://redisdoc.com/hash/index.html\" target=\"_blank\" rel=\"noopener\">Hash</a></p>\n</li>\n<li><p><a href=\"http://redisdoc.com/list/index.html\" target=\"_blank\" rel=\"noopener\">List</a></p>\n</li>\n<li><p><a href=\"http://redisdoc.com/set/index.html\" target=\"_blank\" rel=\"noopener\">Set</a></p>\n</li>\n<li><p><a href=\"http://redisdoc.com/sorted_set/index.html\" target=\"_blank\" rel=\"noopener\">SortedSet</a></p>\n</li>\n</ul>\n<hr>\n<h3 id=\"订阅-amp-发布\"><a href=\"#订阅-amp-发布\" class=\"headerlink\" title=\"订阅 &amp; 发布\"></a>订阅 &amp; 发布</h3><ul>\n<li>所有的订阅都是全局的。</li>\n<li>当你为一个渠道多次订阅时，这个渠道的每次消息发布，会收到多条订阅。</li>\n<li>订阅的消息可以是呈队列有序，也可以是并行的</li>\n</ul>\n<hr>\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><ul>\n<li>redis 不支持回滚</li>\n<li>事务是用来保证即使你有命令的连续执行，在多并发的情况下，希望几条命令是联系执行的时候使用事务。</li>\n<li>事务中的多条命令中有一条或者以上的命令存在语法错误，那么正确的命令即使是 <code>EXEC</code> 也不会被执行 <em>（在Redis 2.6.5之后）</em> 。但是需要注意的是这种错误的事务机制仅限于语法错误。</li>\n<li><code>DISCARD</code> 用来放弃事务, 在执行到 <code>DISCARD</code> 的时候全部的命令将被放弃。如果正在使用 <code>WATCH</code> 命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 <code>UNWATCH</code> 。</li>\n<li><code>WATCH</code> 命令可以为 Redis 事务提供 check-and-set 行为。<br>被 <code>WATCH</code> 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消，set执行失败。</li>\n<li><a href=\"https://github.com/sc1994/.NET-Learn/blob/master/Redis/RedisDemo/Transactions%20in%20Redis.md\" target=\"_blank\" rel=\"noopener\">如何在C#中使用事务</a>(使用StackExchange.Redis)</li>\n</ul>\n<hr>\n<h3 id=\"Redis-集群\"><a href=\"#Redis-集群\" class=\"headerlink\" title=\"Redis 集群\"></a>Redis 集群</h3><ul>\n<li>Redis 集群是一个分布式（distributed）、容错（fault-tolerant）的 Redis 实现， 集群可以使用的功能是普通单机 Redis 所能使用的功能的一个子集（subset）。</li>\n<li>Redis 集群中不存在中心（central）节点或者代理（proxy）节点， 集群的其中一个主要设计目标是达到线性可扩展性（linear scalability）。</li>\n<li>Redis 集群为了保证一致性（consistency）而牺牲了一部分容错性： 系统会在保证对网络断线（net split）和节点失效（node failure）具有有限抵抗力的前提下， 尽可能地保持数据的一致性。</li>\n</ul>\n<hr>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><ul>\n<li>跳跃表<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在跳跃表是由N层链表组成，最底层是最完整的的数据，每次数据插入，率先进入到这个链表（有序的），</span><br><span class=\"line\">插入完成后，通过抛硬币的算法，判断是否将数据向上层跑，如果是1的话，就抛到上层，然后继续抛硬盘，</span><br><span class=\"line\">判断是否继续向上层抛，直到抛出了0结束整个操作，每抛到一层的时候，如果当前层没有数据，就构造一个链表，</span><br><span class=\"line\">将数据放进去，然后使用指针指向来源地址，就这样依次类推，形成了跳跃表，每次查询，从最上层遍历查询，</span><br><span class=\"line\">如果找到就返回结果，否则就在此层找到最接近查询的值，将查询操作移到另外一层，就是刚才说到来源地址，</span><br><span class=\"line\">所在层，重复查询。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"http://118.24.27.231:8088/v2-114f4895c296861aca549d96fc4b563f_r.jpg\" alt=\"image\"></p>\n<ul>\n<li><p>单线程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">单线程的模式解决了数据存储的顽疾：数据并发安全，任何运行多线程同时访问数据库都会存在这个问题。</span><br><span class=\"line\">所以才有了mysql的mvcc和锁， Memcached 的cas 乐观锁，来保证数据不会出现并发导致的数据问题。</span><br><span class=\"line\">但是redis 使用单线程就不存在这个问题：</span><br><span class=\"line\">    1：单线程足够简单，无论在redis的实现还是作为调用方，都不需要为数据并发提心吊胆，不需要加锁。</span><br><span class=\"line\">    2：不会出现不必要的线程调度，你知道多线程，频繁切换上下文，也会带来很多性能消耗。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>多路 I/O 复用模型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多路 I/O 复用模型，这个也是java 的NIO体系使用的IO模型，也是linux诸多IO模型中的一种。</span><br><span class=\"line\">说白了就是当一个请求来访问redis后，redis去组织数据要返回给请求，这个时间段，redis的请求入口不是阻塞的。</span><br><span class=\"line\">其他请求可以继续向redis发送请求，等到redis io流完成后，再向调用者返回数据。</span><br><span class=\"line\">这样一来，单线程也不怕会影响速度了。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h3><ul>\n<li>什么是缓存击穿<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">缓存一般作为RDS的前置系统和服务器直连，减轻rds的负担，常理而言。</span><br><span class=\"line\">如果服务器查询缓存而不得的话，需要从rds中获取然后更新到缓存中，但是如果在“从rds中获取然后更新到缓存中”，</span><br><span class=\"line\">这个阶段，缓存尚未更新成功，大量请求进来的话，rds势必压力暴增，甚至雪崩，或者歹人恶意攻击，</span><br><span class=\"line\">一直查询rds和缓存中未存在key，也会导致缓存机制失效，rds压力暴增，称之为缓存击穿</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<h2 id=\"date：2018年4月19日\"><a href=\"#date：2018年4月19日\" class=\"headerlink\" title=\"date：2018年4月19日\"></a>date：2018年4月19日</h2><h3 id=\"源码安装\"><a href=\"#源码安装\" class=\"headerlink\" title=\"源码安装\"></a>源码安装</h3><ul>\n<li><p>下载</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://download.redis.io/releases/redis-stable.tar.gz</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解压</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xzvf redis-stable.tar.gz</span><br><span class=\"line\">mv redis-stable redis</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd redis</span><br><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改配置reids.conf</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bind 127.0.0.1 --&gt; 0.0.0.0 # 运行远程访问</span><br><span class=\"line\">daemonize no --&gt; yes # 后台运行</span><br><span class=\"line\">database 16 # 库的数量</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src/redis-server redis.conf</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>停止</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src/redis-cli </span><br><span class=\"line\">shutdown</span><br><span class=\"line\">exit</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"apt\"><a href=\"#apt\" class=\"headerlink\" title=\"apt\"></a>apt</h3><ul>\n<li><p>安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install redis-server</span><br><span class=\"line\"># 安装完成就直接启动了, 默认读取的配置文件在/etc/redis/redis.conf</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>停止</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl stop redis-server</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h3><ul>\n<li><p>基本命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull redis </span><br><span class=\"line\">docker run -p 6380:6379 redis # 运行redis镜像映射到主机的6380端口</span><br><span class=\"line\">docker sp -a # 查看容器运行状态</span><br><span class=\"line\">docker start xx # 启动</span><br><span class=\"line\">docker restart xx # 重启容器</span><br><span class=\"line\">docker stop xx # 停止</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用自定义的配置文件<a href=\"https://raw.githubusercontent.com/antirez/redis/8ac7af1c5d4d06d6c165e35d67a3a6a70e5d98c3/redis.conf\" target=\"_blank\" rel=\"noopener\">（完整的配置描述）</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -v /home/ubuntu/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 redis redis-server /usr/local/etc/redis/redis.conf</span><br><span class=\"line\">// 注意修改配置中的数据库文件路径 如：dir ./</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"常用数据结构\"><a href=\"#常用数据结构\" class=\"headerlink\" title=\"常用数据结构\"></a>常用数据结构</h3><ul>\n<li><p><a href=\"http://redisdoc.com/string/index.html\" target=\"_blank\" rel=\"noopener\">Strng</a></p>\n</li>\n<li><p><a href=\"http://redisdoc.com/hash/index.html\" target=\"_blank\" rel=\"noopener\">Hash</a></p>\n</li>\n<li><p><a href=\"http://redisdoc.com/list/index.html\" target=\"_blank\" rel=\"noopener\">List</a></p>\n</li>\n<li><p><a href=\"http://redisdoc.com/set/index.html\" target=\"_blank\" rel=\"noopener\">Set</a></p>\n</li>\n<li><p><a href=\"http://redisdoc.com/sorted_set/index.html\" target=\"_blank\" rel=\"noopener\">SortedSet</a></p>\n</li>\n</ul>\n<hr>\n<h3 id=\"订阅-amp-发布\"><a href=\"#订阅-amp-发布\" class=\"headerlink\" title=\"订阅 &amp; 发布\"></a>订阅 &amp; 发布</h3><ul>\n<li>所有的订阅都是全局的。</li>\n<li>当你为一个渠道多次订阅时，这个渠道的每次消息发布，会收到多条订阅。</li>\n<li>订阅的消息可以是呈队列有序，也可以是并行的</li>\n</ul>\n<hr>\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><ul>\n<li>redis 不支持回滚</li>\n<li>事务是用来保证即使你有命令的连续执行，在多并发的情况下，希望几条命令是联系执行的时候使用事务。</li>\n<li>事务中的多条命令中有一条或者以上的命令存在语法错误，那么正确的命令即使是 <code>EXEC</code> 也不会被执行 <em>（在Redis 2.6.5之后）</em> 。但是需要注意的是这种错误的事务机制仅限于语法错误。</li>\n<li><code>DISCARD</code> 用来放弃事务, 在执行到 <code>DISCARD</code> 的时候全部的命令将被放弃。如果正在使用 <code>WATCH</code> 命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 <code>UNWATCH</code> 。</li>\n<li><code>WATCH</code> 命令可以为 Redis 事务提供 check-and-set 行为。<br>被 <code>WATCH</code> 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消，set执行失败。</li>\n<li><a href=\"https://github.com/sc1994/.NET-Learn/blob/master/Redis/RedisDemo/Transactions%20in%20Redis.md\" target=\"_blank\" rel=\"noopener\">如何在C#中使用事务</a>(使用StackExchange.Redis)</li>\n</ul>\n<hr>\n<h3 id=\"Redis-集群\"><a href=\"#Redis-集群\" class=\"headerlink\" title=\"Redis 集群\"></a>Redis 集群</h3><ul>\n<li>Redis 集群是一个分布式（distributed）、容错（fault-tolerant）的 Redis 实现， 集群可以使用的功能是普通单机 Redis 所能使用的功能的一个子集（subset）。</li>\n<li>Redis 集群中不存在中心（central）节点或者代理（proxy）节点， 集群的其中一个主要设计目标是达到线性可扩展性（linear scalability）。</li>\n<li>Redis 集群为了保证一致性（consistency）而牺牲了一部分容错性： 系统会在保证对网络断线（net split）和节点失效（node failure）具有有限抵抗力的前提下， 尽可能地保持数据的一致性。</li>\n</ul>\n<hr>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><ul>\n<li>跳跃表<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在跳跃表是由N层链表组成，最底层是最完整的的数据，每次数据插入，率先进入到这个链表（有序的），</span><br><span class=\"line\">插入完成后，通过抛硬币的算法，判断是否将数据向上层跑，如果是1的话，就抛到上层，然后继续抛硬盘，</span><br><span class=\"line\">判断是否继续向上层抛，直到抛出了0结束整个操作，每抛到一层的时候，如果当前层没有数据，就构造一个链表，</span><br><span class=\"line\">将数据放进去，然后使用指针指向来源地址，就这样依次类推，形成了跳跃表，每次查询，从最上层遍历查询，</span><br><span class=\"line\">如果找到就返回结果，否则就在此层找到最接近查询的值，将查询操作移到另外一层，就是刚才说到来源地址，</span><br><span class=\"line\">所在层，重复查询。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"http://118.24.27.231:8088/v2-114f4895c296861aca549d96fc4b563f_r.jpg\" alt=\"image\"></p>\n<ul>\n<li><p>单线程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">单线程的模式解决了数据存储的顽疾：数据并发安全，任何运行多线程同时访问数据库都会存在这个问题。</span><br><span class=\"line\">所以才有了mysql的mvcc和锁， Memcached 的cas 乐观锁，来保证数据不会出现并发导致的数据问题。</span><br><span class=\"line\">但是redis 使用单线程就不存在这个问题：</span><br><span class=\"line\">    1：单线程足够简单，无论在redis的实现还是作为调用方，都不需要为数据并发提心吊胆，不需要加锁。</span><br><span class=\"line\">    2：不会出现不必要的线程调度，你知道多线程，频繁切换上下文，也会带来很多性能消耗。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>多路 I/O 复用模型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多路 I/O 复用模型，这个也是java 的NIO体系使用的IO模型，也是linux诸多IO模型中的一种。</span><br><span class=\"line\">说白了就是当一个请求来访问redis后，redis去组织数据要返回给请求，这个时间段，redis的请求入口不是阻塞的。</span><br><span class=\"line\">其他请求可以继续向redis发送请求，等到redis io流完成后，再向调用者返回数据。</span><br><span class=\"line\">这样一来，单线程也不怕会影响速度了。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h3><ul>\n<li>什么是缓存击穿<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">缓存一般作为RDS的前置系统和服务器直连，减轻rds的负担，常理而言。</span><br><span class=\"line\">如果服务器查询缓存而不得的话，需要从rds中获取然后更新到缓存中，但是如果在“从rds中获取然后更新到缓存中”，</span><br><span class=\"line\">这个阶段，缓存尚未更新成功，大量请求进来的话，rds势必压力暴增，甚至雪崩，或者歹人恶意攻击，</span><br><span class=\"line\">一直查询rds和缓存中未存在key，也会导致缓存机制失效，rds压力暴增，称之为缓存击穿</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"_content":"","source":"_posts/hangfire.md","raw":"","slug":"hangfire","published":1,"date":"2018-09-18T01:50:51.872Z","updated":"2018-09-18T01:52:32.445Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm72e6kq00008guddt3zoxmf","content":"","site":{"data":{}},"excerpt":"","more":""}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjldtqr5p0000ewude5mri1gb","tag_id":"cjldtqr610002ewudi1m532jd","_id":"cjldtqr6d0005ewudn687njfd"},{"post_id":"cjldtqr5y0001ewudhouxo3sa","tag_id":"cjldtqr610002ewudi1m532jd","_id":"cjldtqr6e0007ewudlzahslpr"},{"post_id":"cjldtqr670003ewud8utfo9cp","tag_id":"cjldtqr610002ewudi1m532jd","_id":"cjldtqr6f0008ewud9lc851ct"},{"post_id":"cjldtqr7u0009ewud3ta9bliu","tag_id":"cjldtqr610002ewudi1m532jd","_id":"cjldtqr81000aewud80bcdxmg"}],"Tag":[{"name":"备忘","_id":"cjldtqr610002ewudi1m532jd"}]}}